/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */

import {
  Address,
  CartDiscountKeyReference,
  ChannelKeyReference,
  CustomerGroupKeyReference,
  CustomerKeyReference,
  DiscountCodeKeyReference,
  DiscountedPrice,
  Image,
  LocalizedString,
  Money,
  PriceTier,
  ProductKeyReference,
  ProductVariantKeyReference,
  ShippingMethodKeyReference,
  StateKeyReference,
  StoreKeyReference,
  TaxCategoryKeyReference,
  TypedMoney,
} from './common'
import { Custom } from './customfields'
import { SubRate, TaxRate } from './prices'
import { Attribute } from './productvariants'

export interface ItemState {
  /**
   *	Number of Line Items or Custom Line Items in this State.
   *
   *
   */
  readonly quantity: number
  /**
   *	State of the Line Items or Custom Line Items in a custom workflow. If the referenced [State](ctp:api:type:State) does not exist, the `state` of the [ImportOperation](ctp:import:type:ImportOperation) will be set to `unresolved` until the referenced State is created.
   *
   *
   */
  readonly state: StateKeyReference
}
/**
 *	Determines the address (as a reference to an address in `itemShippingAddresses`) and the quantity shipped to the address.
 *
 */
export interface ItemShippingTarget {
  /**
   *	Key of the address in the [Cart](ctp:api:type:Cart) `itemShippingAddresses`. Duplicate address keys are not allowed.
   *
   *
   */
  readonly addressKey: string
  /**
   *	Quantity of Line Items or Custom Line Items shipped to the address with the specified `addressKey`.
   *
   *
   */
  readonly quantity: number
}
/**
 *	The sum of the `targets` must match the quantity of the Line Items or Custom Line Items
 */
export interface ItemShippingDetailsDraft {
  /**
   *	Holds information on the quantity of Line Items or Custom Line Items and the address it is shipped.
   *
   *
   */
  readonly targets: ItemShippingTarget[]
}
export interface LineItemPrice {
  /**
   *	Maps to `Price.value`.
   *
   *
   */
  readonly value: TypedMoney
  /**
   *	Maps to `Price.county`.
   *
   *
   */
  readonly country?: string
  /**
   *	Maps to `Price.validFrom`.
   *
   *
   */
  readonly validFrom?: string
  /**
   *	Maps to `Price.validUntil`.
   *
   *
   */
  readonly validUntil?: string
  /**
   *	Maps to `Price.customerGroup`. References a customer group by key. If the referenced [CustomerGroup](ctp:api:type:CustomerGroup) does not exist, the `state` of the [ImportOperation](ctp:import:type:ImportOperation) will be set to `unresolved` until the referenced CustomerGroup is created.
   *
   *
   */
  readonly customerGroup?: CustomerGroupKeyReference
  /**
   *	Maps to `Price.channel`. References a channel by key. If the referenced [Channel](ctp:api:type:Channel) does not exist, the `state` of the [ImportOperation](ctp:import:type:ImportOperation) will be set to `unresolved` until the referenced Channel is created.
   *
   *
   */
  readonly channel?: ChannelKeyReference
  /**
   *	Sets a discounted price from an external service.
   *
   */
  readonly discounted?: DiscountedPrice
  /**
   *	Maps to `Price.tiers`.
   *
   */
  readonly tiers?: PriceTier[]
  /**
   *	Maps to `Price.custom`.
   *
   *
   */
  readonly custom?: Custom
}
export interface LineItemProductVariantImportDraft {
  /**
   *	Maps to `ProductVariant.product`. If the referenced [ProductVariant](ctp:api:type:ProductVariant) does not exist, the `state` of the [ImportOperation](ctp:import:type:ImportOperation) will be set to `unresolved` until the referenced ProductVariant is created.
   *
   *
   */
  readonly productVariant?: ProductVariantKeyReference
  /**
   *	Maps to `ProductVariantImportDraft.sku`.
   *
   *
   */
  readonly sku?: string
  /**
   *	Maps to `ProductVariantImportDraft.prices`
   *
   *
   */
  readonly prices?: LineItemPrice[]
  /**
   *	Maps to `ProductVariantImportDraft.attributes`
   *
   *
   */
  readonly attributes?: Attribute[]
  /**
   *	Maps to `ProductVariantImportDraft.images`.
   *
   *
   */
  readonly images?: Image[]
}
/**
 *	Represents an individual Line Item in an Order. A line item is a snapshot of a product at the time it was added to the order.
 *
 *	You cannot create an Order that includes line item operations that do not exist in the Project or have been deleted.
 *	Products and Product Variants referenced by a line item must already exist in the Project.
 *	Product Attributes are merged with Variant Attributes to ensure the full Attribute context of the Product Variant.
 *
 */
export interface LineItemImportDraft {
  /**
   *	Maps to `LineItem.productId`. If the referenced [Product](ctp:api:type:Product) does not exist, the `state` of the [ImportOperation](ctp:import:type:ImportOperation) will be set to `unresolved` until the referenced Product is created.
   *
   *
   */
  readonly product?: ProductKeyReference
  /**
   *	Maps to `LineItem.name`.
   *
   *
   */
  readonly name: LocalizedString
  /**
   *	Maps to `ProductVariantImportDraft`.
   *
   *
   */
  readonly variant: LineItemProductVariantImportDraft
  /**
   *	Maps to `LineItem.price`.
   *
   *
   */
  readonly price: LineItemPrice
  /**
   *	Maps to `LineItem.quantity`.
   *
   *
   */
  readonly quantity: number
  /**
   *	Maps to `LineItem.state`.
   *
   *
   */
  readonly state?: ItemState[]
  /**
   *	Maps to `LineItem.supplyChannel`. If the referenced [Channel](ctp:api:type:Channel) does not exist, the `state` of the [ImportOperation](ctp:import:type:ImportOperation) will be set to `unresolved` until the referenced Channel is created.
   *
   *
   */
  readonly supplyChannel?: ChannelKeyReference
  /**
   *	Maps to `LineItem.distributionChannel`. If the referenced [Channel](ctp:api:type:Channel) does not exist, the `state` of the [ImportOperation](ctp:import:type:ImportOperation) will be set to `unresolved` until the referenced Channel is created.
   *
   *
   */
  readonly distributionChannel?: ChannelKeyReference
  /**
   *	Maps to `LineItem.taxRate`.
   *
   *
   */
  readonly taxRate?: TaxRate
  /**
   *	Maps to `LineItem.shippingDetails`.
   *
   *
   */
  readonly shippingDetails?: ItemShippingDetailsDraft
  /**
   *	Maps to `LineItem.custom`.
   *
   */
  readonly custom?: Custom
}
export enum ShippingRateTierTypeValues {
  CartClassification = 'CartClassification',
  CartScore = 'CartScore',
  CartValue = 'CartValue',
}

export type ShippingRateTierType =
  | 'CartClassification'
  | 'CartScore'
  | 'CartValue'
  | (string & {})
export type ShippingRatePriceTier = CartClassificationTier
export interface IShippingRatePriceTier {
  /**
   *
   */
  readonly type: ShippingRateTierType
}
export interface CartClassificationTier extends IShippingRatePriceTier {
  readonly type: 'CartClassification'
  /**
   *
   */
  readonly value: string
  /**
   *
   */
  readonly price: Money
  /**
   *
   */
  readonly tiers: ShippingRatePriceTier[]
  /**
   *
   */
  readonly isMatching?: boolean
}
export interface ShippingRateDraft {
  /**
   *	Currency amount of the ShippingRate.
   *
   */
  readonly price: Money
  /**
   *	Free shipping is applied if the sum of the (Custom) Line Item Prices reaches the specified value.
   *
   */
  readonly freeAbove?: Money
  /**
   *	Price tiers for the ShippingRate.
   *
   */
  readonly tiers?: ShippingRatePriceTier[]
}
export interface ParcelMeasurements {
  /**
   *	Height of the Parcel.
   *
   *
   */
  readonly heightInMillimeter?: number
  /**
   *	Length of the Parcel.
   *
   *
   */
  readonly lengthInMillimeter?: number
  /**
   *	Width of the Parcel.
   *
   *
   */
  readonly widthInMillimeter?: number
  /**
   *	Weight of the Parcel.
   *
   *
   */
  readonly weightInGram?: number
}
export interface TrackingData {
  /**
   *	Identifier to track the Parcel.
   *
   *
   */
  readonly trackingId?: string
  /**
   *	Name of the carrier that delivers the Parcel.
   *
   *
   */
  readonly carrier?: string
  /**
   *	Name of the provider that serves as facade to several carriers.
   *
   *
   */
  readonly provider?: string
  /**
   *	Transaction identifier with the `provider`.
   *
   *
   */
  readonly providerTransaction?: string
  /**
   *	- If `true`, the Parcel is being returned.
   *	- If `false`, the Parcel is being delivered to the customer.
   *
   *
   */
  readonly isReturn?: boolean
}
export interface DeliveryItem {
  /**
   *	`id` of the [LineItem](ctp:api:type:LineItem) or [CustomLineItem](ctp:api:type:CustomLineItem) delivered.
   *
   *
   */
  readonly id: string
  /**
   *	Number of Line Items or Custom Line Items delivered.
   *
   *
   */
  readonly quantity: number
}
export interface Parcel {
  /**
   *	Unique identifier of the Parcel.
   *
   */
  readonly id: string
  /**
   *	Date and time (UTC) the Parcel was created.
   *
   *
   */
  readonly createdAt: string
  /**
   *	Information about the dimensions of the Parcel.
   *
   *
   */
  readonly measurements?: ParcelMeasurements
  /**
   *	Shipment tracking information of the Parcel.
   *
   *
   */
  readonly trackingData?: TrackingData
  /**
   *	Line Items or Custom Line Items delivered in this Parcel.
   *
   *
   */
  readonly items?: DeliveryItem[]
  /**
   *	Custom Fields of the Parcel.
   *
   *
   */
  readonly custom?: Custom
}
export interface Delivery {
  /**
   *	Unique identifier of the Delivery.
   *
   */
  readonly id: string
  /**
   *	Date and time (UTC) the Delivery was created.
   *
   *
   */
  readonly createdAt: string
  /**
   *	Line Items or Custom Line Items that are delivered.
   *
   *
   */
  readonly items: DeliveryItem[]
  /**
   *	Information regarding the appearance, content, and shipment of a Parcel.
   *
   *
   */
  readonly parcels: Parcel[]
  /**
   *	Address to which Parcels are delivered.
   *
   *
   */
  readonly address?: Address
}
export interface DiscountedLineItemPortion {
  /**
   *	References a cart discount by key. If the referenced [CartDiscount](ctp:api:type:CartDiscount) does not exist, the `state` of the [ImportOperation](ctp:import:type:ImportOperation) will be set to `unresolved` until the referenced CartDiscount is created.
   *
   */
  readonly discount: CartDiscountKeyReference
  /**
   *	Money value for the discount applicable.
   *
   */
  readonly discountedAmount: Money
}
export interface DiscountedLineItemPriceDraft {
  /**
   *	Discounted money value.
   *
   *
   */
  readonly value: Money
  /**
   *	Discounts to be applied.
   *
   */
  readonly includedDiscounts: DiscountedLineItemPortion[]
}
export enum ShippingMethodStateValues {
  DoesNotMatchCart = 'DoesNotMatchCart',
  MatchesCart = 'MatchesCart',
}

export type ShippingMethodState =
  | 'DoesNotMatchCart'
  | 'MatchesCart'
  | (string & {})
/**
 *	Maps to an Order's `shippingInfo` property. This field is usually populated by the Cart associated with the Order, but when importing Orders you must provide a draft representation as a part of the OrderImport.
 *
 */
export interface ShippingInfoImportDraft {
  /**
   *	Maps to `shippingInfo.shippingMethodName`.
   *
   */
  readonly shippingMethodName: string
  /**
   *	Maps to `shippingInfo.price`.
   *
   */
  readonly price: TypedMoney
  /**
   *	Used to determine the price.
   *
   */
  readonly shippingRate: ShippingRateDraft
  /**
   *	Maps to `shippingInfo.taxRate`.
   *
   */
  readonly taxRate?: TaxRate
  /**
   *	Maps to `shippingInfo.taxCategory`. If the referenced [TaxCategory](ctp:api:type:TaxCategory) does not exist, the `state` of the [ImportOperation](ctp:import:type:ImportOperation) will be set to `unresolved` until the referenced TaxCategory is created.
   *
   */
  readonly taxCategory?: TaxCategoryKeyReference
  /**
   *	Maps to `shippingInfo.shippingMethod`. If the referenced [ShippingMethod](ctp:api:type:ShippingMethod) does not exist, the `state` of the [ImportOperation](ctp:import:type:ImportOperation) will be set to `unresolved` until the referenced ShippingMethod is created.
   *
   */
  readonly shippingMethod?: ShippingMethodKeyReference
  /**
   *	Maps to `shippingInfo.deliveries`. You cannot add a `DeliveryItem` on import, as `LineItems` and `CustomLineItems` are not yet referenceable by an `id`.
   *
   */
  readonly deliveries?: Delivery[]
  /**
   *	Maps to `shippingInfo.discountedPrice`.
   *
   */
  readonly discountedPrice?: DiscountedLineItemPriceDraft
  /**
   *	Maps to `shippingInfo.shippingMethodState`.
   *
   */
  readonly shippingMethodState?: ShippingMethodState
}
export interface ExternalTaxRateDraft {
  /**
   *	Name of the Tax Rate.
   *
   *
   */
  readonly name: string
  /**
   *	Percentage in the range of 0-1.
   *
   *	- If no `subRates` are specified, a value must be defined.
   *	- If `subRates` are specified, this can be omitted or its value must be the sum of all `subRates` amounts.
   *
   *
   */
  readonly amount?: number
  /**
   *	Country for which the tax applies.
   *
   *
   */
  readonly country: string
  /**
   *	State within the specified country.
   *
   *
   */
  readonly state?: string
  /**
   *	Used when the total tax is a combination of multiple taxes (for example, local, state/provincial, and/or federal taxes). The total of all subrates must equal the TaxRate `amount`.
   *	These subrates are used to calculate the `taxPortions` field of a [Cart](ctp:api:type:Cart) or [Order](ctp:api:type:Order) and the `taxedPrice` field of [LineItems](ctp:api:type:LineItem), [CustomLineItems](ctp:api:type:CustomLineItem), and [ShippingInfos](ctp:api:type:ShippingInfo).
   *
   *
   */
  readonly subRates?: SubRate[]
  /**
   *	- If set to `false`, the related price is considered the net price and the provided `amount` is applied to calculate the gross price.
   *	- If set to `true`, the related price is considered the gross price, and the provided `amount` is applied to calculate the net price.
   *
   *
   */
  readonly includedInPrice?: boolean
}
export interface CustomLineItemTaxedPrice {
  /**
   *
   */
  readonly totalNet: TypedMoney
  /**
   *
   */
  readonly totalGross: TypedMoney
}
export interface CustomLineItemDraft {
  /**
   *	Maps to `CustomLineItem.name`.
   *
   *
   */
  readonly name: LocalizedString
  /**
   *	Maps to `CustomLineItem.money`.
   *
   *
   */
  readonly money: TypedMoney
  /**
   *	Maps to `CustomLineItem.taxedPrice`.
   *
   *
   */
  readonly taxedPrice?: CustomLineItemTaxedPrice
  /**
   *	Maps to `CustomLineItem.totalPrice`.
   *
   *
   */
  readonly totalPrice: TypedMoney
  /**
   *	Maps to `CustomLineItem.slug`.
   *
   *
   */
  readonly slug: string
  /**
   *	Maps to `CustomLineItem.quantity`.
   *
   *
   */
  readonly quantity: number
  /**
   *	Maps to `CustomLineItem.state`.
   *
   *
   */
  readonly state?: ItemState[]
  /**
   *	Maps to `CustomLineItem.taxCategory`. References a tax category by key. If the referenced [TaxCategory](ctp:api:type:TaxCategory) does not exist, the `state` of the [ImportOperation](ctp:import:type:ImportOperation) will be set to `unresolved` until the referenced TaxCategory is created.
   *
   *
   */
  readonly taxCategory?: TaxCategoryKeyReference
  /**
   *	Maps to `CustomLineItem.taxRate`.
   *
   *
   */
  readonly taxRate?: TaxRate
  /**
   *	External Tax Rate for the Custom Line Item if the Cart has the `External` [TaxMode](ctp:api:type:TaxMode).
   *
   *
   */
  readonly externalTaxRate?: ExternalTaxRateDraft
  /**
   *	Maps to `CustomLineItem.discountedPricePerQuantity`.
   *
   *
   */
  readonly discountedPricePerQuantity?: DiscountedLineItemPriceDraft[]
  /**
   *	Maps to `CustomLineItem.shippingDetails`.
   *
   *
   */
  readonly shippingDetails?: ItemShippingDetailsDraft
}
export interface TaxPortion {
  /**
   *	Name of the tax portion.
   *
   *
   */
  readonly name?: string
  /**
   *	A number in the range 0-1.
   *
   *
   */
  readonly rate: number
  /**
   *	Money value of the tax portion.
   *
   *
   */
  readonly amount: TypedMoney
}
export interface TaxedPrice {
  /**
   *	Maps to `TaxedPrice.totalNet`.
   *
   */
  readonly totalNet: Money
  /**
   *	Maps to `TaxedPrice.totalGross`.
   *
   */
  readonly totalGross: Money
  /**
   *	Maps to `TaxedPrice.taxPortions`.
   *
   */
  readonly taxPortions: TaxPortion[]
}
/**
 *	Maps to `Order.taxMode`
 */
export enum TaxModeValues {
  Disabled = 'Disabled',
  External = 'External',
  ExternalAmount = 'ExternalAmount',
  Platform = 'Platform',
}

export type TaxMode =
  | 'Disabled'
  | 'External'
  | 'ExternalAmount'
  | 'Platform'
  | (string & {})
/**
 *	Maps to `Order.orderState`.
 */
export enum OrderStateValues {
  Cancelled = 'Cancelled',
  Complete = 'Complete',
  Confirmed = 'Confirmed',
  Open = 'Open',
}

export type OrderState =
  | 'Cancelled'
  | 'Complete'
  | 'Confirmed'
  | 'Open'
  | (string & {})
/**
 *	Maps to `Order.shipmentState`.
 */
export enum ShipmentStateValues {
  Backorder = 'Backorder',
  Delayed = 'Delayed',
  Partial = 'Partial',
  Pending = 'Pending',
  Ready = 'Ready',
  Shipped = 'Shipped',
}

export type ShipmentState =
  | 'Backorder'
  | 'Delayed'
  | 'Partial'
  | 'Pending'
  | 'Ready'
  | 'Shipped'
  | (string & {})
/**
 *	Maps to `Order.paymentState`.
 */
export enum PaymentStateValues {
  BalanceDue = 'BalanceDue',
  CreditOwed = 'CreditOwed',
  Failed = 'Failed',
  Paid = 'Paid',
  Pending = 'Pending',
}

export type PaymentState =
  | 'BalanceDue'
  | 'CreditOwed'
  | 'Failed'
  | 'Paid'
  | 'Pending'
  | (string & {})
/**
 *	Maps to `Order.inventoryMode`.
 */
export enum InventoryModeValues {
  ReserveOnOrder = 'ReserveOnOrder',
  TrackOnly = 'TrackOnly',
}

export type InventoryMode = 'ReserveOnOrder' | 'TrackOnly' | (string & {})
/**
 *	The rounding mode representation used in `Order.priceRoundingMode` and `Order.taxRoundingMode`.
 */
export enum RoundingModeValues {
  HalfDown = 'HalfDown',
  HalfEven = 'HalfEven',
  HalfUp = 'HalfUp',
}

export type RoundingMode = 'HalfDown' | 'HalfEven' | 'HalfUp' | (string & {})
/**
 *	Maps to `Order.taxCalculationMode`.
 */
export enum TaxCalculationModeValues {
  LineItemLevel = 'LineItemLevel',
  UnitPriceLevel = 'UnitPriceLevel',
}

export type TaxCalculationMode =
  | 'LineItemLevel'
  | 'UnitPriceLevel'
  | (string & {})
/**
 *	Maps to `Order.origin`.
 */
export enum CartOriginValues {
  Customer = 'Customer',
  Merchant = 'Merchant',
}

export type CartOrigin = 'Customer' | 'Merchant' | (string & {})
export interface SyncInfo {
  /**
   *	Maps to `SyncInfo.channel`. If the referenced [Channel](ctp:api:type:Channel) does not exist, the `state` of the [ImportOperation](ctp:import:type:ImportOperation) will be set to `unresolved` until the referenced Channel is created.
   *
   */
  readonly channel: ChannelKeyReference
  /**
   *	Maps to `SyncInfo.externalId`
   *
   */
  readonly externalId?: string
  /**
   *	Maps to `SyncInfo.syncedAt`
   *
   */
  readonly syncedAt: string
}
/**
 *	Maps to `DiscountCodeInfo.state`
 */
export enum DiscountCodeStateValues {
  ApplicationStoppedByPreviousDiscount = 'ApplicationStoppedByPreviousDiscount',
  DoesNotMatchCart = 'DoesNotMatchCart',
  MatchesCart = 'MatchesCart',
  MaxApplicationReached = 'MaxApplicationReached',
  NotActive = 'NotActive',
  NotValid = 'NotValid',
}

export type DiscountCodeState =
  | 'ApplicationStoppedByPreviousDiscount'
  | 'DoesNotMatchCart'
  | 'MatchesCart'
  | 'MaxApplicationReached'
  | 'NotActive'
  | 'NotValid'
  | (string & {})
export interface DiscountCodeInfo {
  /**
   *	References a DiscountCode by key. If the referenced [DiscountCode](ctp:api:type:DiscountCode) does not exist, the `state` of the [ImportOperation](ctp:import:type:ImportOperation) will be set to `unresolved` until the referenced DiscountCode is created.
   *
   */
  readonly discountCode: DiscountCodeKeyReference
  /**
   *	Maps to `DiscountCodeInfo.state`
   *
   */
  readonly state?: DiscountCodeState
}
export enum ShippingRateInputTypeValues {
  Classification = 'Classification',
  Score = 'Score',
}

export type ShippingRateInputType = 'Classification' | 'Score' | (string & {})
export type ShippingRateInput =
  | ClassificationShippingRateInput
  | ScoreShippingRateInput
export interface IShippingRateInput {
  /**
   *
   */
  readonly type: ShippingRateInputType
}
export interface ClassificationShippingRateInput extends IShippingRateInput {
  readonly type: 'Classification'
  /**
   *
   */
  readonly key: string
  /**
   *	A localized string is a JSON object where the keys are of [IETF language tag](https://en.wikipedia.org/wiki/IETF_language_tag), and the values the corresponding strings used for that language.
   *	```json
   *	{
   *	  "de": "Hundefutter",
   *	  "en": "dog food"
   *	}
   *	```
   *
   *
   */
  readonly label: LocalizedString
}
export interface ScoreShippingRateInput extends IShippingRateInput {
  readonly type: 'Score'
  /**
   *
   */
  readonly score: number
}
/**
 *	Represents the data used to import an Order. Once imported, this data is persisted as an [Order](ctp:api:type:Order) in the Project.
 *
 *	An OrderImport is a snapshot of an order at the time it was imported.
 *
 */
export interface OrderImport {
  /**
   *	Maps to `Order.orderNumber`, String that uniquely identifies an order. It should be unique across a project. Once it's set it cannot be changed.
   *
   *
   */
  readonly orderNumber: string
  /**
   *	`key` of the [Customer](ctp:api:type:Customer) that the Order belongs to. If the referenced Customer does not exist, the `state` of the [ImportOperation](ctp:import:type:ImportOperation) will be set to `unresolved` until the referenced Customer is created.
   *
   *
   */
  readonly customer?: CustomerKeyReference
  /**
   *	Maps to `Order.customerEmail`.
   *
   *
   */
  readonly customerEmail?: string
  /**
   *	Maps to `Order.lineItems`.
   *
   *
   */
  readonly lineItems?: LineItemImportDraft[]
  /**
   *	Maps to `Order.customLineItems`
   *
   *
   */
  readonly customLineItems?: CustomLineItemDraft[]
  /**
   *	Maps to `Order.totalPrice`.
   *
   *
   */
  readonly totalPrice: TypedMoney
  /**
   *	Maps to `Order.taxedPrice`.
   *
   *
   */
  readonly taxedPrice?: TaxedPrice
  /**
   *	Maps to `Order.shippingAddress`.
   *
   *
   */
  readonly shippingAddress?: Address
  /**
   *	Maps to `Order.billingAddress`.
   *
   *
   */
  readonly billingAddress?: Address
  /**
   *	Maps to `Order.customerGroup`. If the referenced [CustomerGroup](ctp:api:type:CustomerGroup) does not exist, the `state` of the [ImportOperation](ctp:import:type:ImportOperation) will be set to `unresolved` until the referenced CustomerGroup is created.
   *
   *
   */
  readonly customerGroup?: CustomerGroupKeyReference
  /**
   *	Maps to `Order.country`.
   *
   *
   */
  readonly country?: string
  /**
   *	Maps to `Order.orderState`.
   *
   *
   */
  readonly orderState?: OrderState
  /**
   *	Maps to `Order.shipmentState`.
   *
   *
   */
  readonly shipmentState?: ShipmentState
  /**
   *	Maps to `Order.paymentState`.
   *
   *
   */
  readonly paymentState?: PaymentState
  /**
   *	Maps to `Order.shippingInfo`.
   *
   *
   */
  readonly shippingInfo?: ShippingInfoImportDraft
  /**
   *	Maps to `Order.completedAt`.
   *
   *
   */
  readonly completedAt?: string
  /**
   *	Maps to `Order.custom`.
   *
   *
   */
  readonly custom?: Custom
  /**
   *	Maps to `Order.inventoryMode`.
   *
   *
   */
  readonly inventoryMode?: InventoryMode
  /**
   *	Maps to `Order.taxRoundingMode`.
   *
   *
   */
  readonly taxRoundingMode?: RoundingMode
  /**
   *	Maps to `Order.taxCalculationMode`.
   *
   *
   */
  readonly taxCalculationMode?: TaxCalculationMode
  /**
   *	Maps to `Order.origin`.
   *
   *
   */
  readonly origin?: CartOrigin
  /**
   *	Maps to `Order.itemShippingAddresses`.
   *
   *
   */
  readonly itemShippingAddresses?: Address[]
  /**
   *	Maps to `Order.store`. If the referenced [Store](ctp:api:type:Store) does not exist, the `state` of the [ImportOperation](ctp:import:type:ImportOperation) will be set to `unresolved` until the referenced Store is created.
   *
   *
   */
  readonly store?: StoreKeyReference
  /**
   *	Maps to `Order.state`. If the referenced [State](ctp:api:type:State) does not exist, the `state` of the [ImportOperation](ctp:import:type:ImportOperation) will be set to `unresolved` until the referenced State is created.
   *
   *
   */
  readonly state?: StateKeyReference
}
