import { UpdateAction } from '@commercetools/sdk-client-v2'
import { Delta } from './diffpatcher'

const REGEX_NUMBER = new RegExp(/^\d+$/)
const REGEX_UNDERSCORE_NUMBER = new RegExp(/^_\d+$/)

export const ADD_ACTIONS = 'create'
export const REMOVE_ACTIONS = 'remove'
export const CHANGE_ACTIONS = 'change'

/**
 * Tests a delta to see if it represents a create action.
 * eg. delta:
 * {
 *   0: [ { foo: 'bar' } ]
 * }
 *
 * @param  {object}  obj The delta generated by the diffpatcher
 * @param  {string}  key key of generated delta to examine
 * @return {Boolean}     Returns true if delta represents a create action,
 *   false otherwise
 */
function isCreateAction(obj: { [key: string]: any }, key: string): boolean {
  return (
    REGEX_NUMBER.test(key) && Array.isArray(obj[key]) && obj[key].length === 1
  )
}

/**
 * Tests a delta to see if it represents a change action.
 * eg. delta:
 *
 * {
 *   0: {
 *     foo: ['bar', 'baz']
 *   }
 * }
 * @param  {object}  obj The delta generated by the diffpatcher
 * @param  {string}  key key of generated delta to examine
 * @return {Boolean}     Returns true if delta represents a change action,
 *   false otherwise
 */
function isChangeAction(obj: any, key: string): boolean {
  return (
    REGEX_NUMBER.test(key) &&
    (typeof obj[key] === 'object' || typeof obj[key] === 'string')
  )
}

/**
 * Tests a delta to see if it represents a remove action.
 * eg. delta:
 *
 * {
 *   _0: [ 'foo', 0, 0 ]
 * }
 * @param  {object}  obj The delta generated by the diffpatcher
 * @param  {string}  key key of generated delta to examine
 * @return {Boolean}     Returns true if delta represents a remove action,
 *   false otherwise
 */
function isRemoveAction(obj: any, key: string): boolean {
  return (
    REGEX_UNDERSCORE_NUMBER.test(key) &&
    Array.isArray(obj[key]) &&
    obj[key].length === 3 &&
    (typeof obj[key][0] === 'object' || typeof obj[key][0] === 'string') &&
    obj[key][1] === 0 &&
    obj[key][2] === 0
  )
}

/**
 * Generate + configure a function to build actions for nested objects
 * @param  {string} key    key of the attribute containing the array of
 *   nested objects
 * @param  {object} config configuration object that can contain the keys
 *   [ADD_ACTIONS, REMOVE_ACTIONS, CHANGE_ACTIONS], each of
 *   which is a function. The function should accept the old + new arrays and
 *   return an action object.
 */
export default function createBuildArrayActions(
  key: string,
  config: {
    [ADD_ACTIONS]?: (
      newItem: any,
      key?: number
    ) => UpdateAction | Array<UpdateAction>
    [REMOVE_ACTIONS]?: (oldItem: any, key?: number) => UpdateAction
    [CHANGE_ACTIONS]?: (
      oldAsset: any,
      newAsset: any,
      key?: number
    ) => UpdateAction | Array<UpdateAction>
  }
) {
  return function buildArrayActions(
    diff: Delta,
    oldObj: any,
    newObj: any
  ): Array<UpdateAction> {
    let addActions: Array<UpdateAction> = []
    const removeActions: Array<UpdateAction> = []
    let changeActions: Array<UpdateAction> = []

    if (diff[key]) {
      const arrayDelta = diff[key]

      Object.keys(arrayDelta).forEach((index) => {
        if (config[ADD_ACTIONS] && isCreateAction(arrayDelta, index)) {
          const actionGenerator = config[ADD_ACTIONS]
          // When adding a new element you don't need the oldObj
          const action = actionGenerator(
            newObj[key][index],
            parseInt(index, 10)
          )

          if (action) {
            if (Array.isArray(action)) {
              addActions = addActions.concat(action)
            } else {
              addActions.push(action)
            }
          }
        } else if (
          config[CHANGE_ACTIONS] &&
          isChangeAction(arrayDelta, index)
        ) {
          const actionGenerator = config[CHANGE_ACTIONS]
          // When changing an existing element you need both old + new
          const action = actionGenerator(
            oldObj[key][index],
            newObj[key][index],
            parseInt(index, 10)
          )

          if (action) {
            if (Array.isArray(action)) {
              changeActions = changeActions.concat(action)
            } else {
              changeActions.push(action)
            }
          }
        } else if (
          config[REMOVE_ACTIONS] &&
          isRemoveAction(arrayDelta, index)
        ) {
          const realIndex = index.replace('_', '')
          const actionGenerator = config[REMOVE_ACTIONS]
          // When removing an existing element you don't need the newObj
          const action = actionGenerator(
            oldObj[key][realIndex],
            parseInt(realIndex, 10)
          )

          if (action) removeActions.push(action)
        }
      })
    }

    return changeActions.concat(removeActions, addActions)
  }
}
